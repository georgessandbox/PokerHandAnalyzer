----QUIT----2020-01-20T13:35:35.914003+01:00 Pharo8.0.0-0-32bit-bbcdf97.image priorSource: 0!----QUIT----2020-01-20T13:35:58.613469+01:00 Pharo8.0.0-0-32bit-bbcdf97.image priorSource: 0!----QUIT----2020-01-20T13:33:29.196908-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 95!----SNAPSHOT----2020-01-20T13:33:39.303298-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 190!----QUIT----2020-01-20T14:54:23.810298-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 286!!ProfStef class methodsFor: 'as yet unclassified' stamp: 'Anonymous 1/22/2020 13:49' prior: 56291712!goToNextLesson  self next! !!ProfStef class methodsFor: 'as yet unclassified' stamp: 'georg 1/22/2020 13:49' prior: 33555019!goToNextLesson  self next! !!ProfStef class methodsFor: 'as yet unclassified' stamp: 'georg 1/22/2020 13:49' prior: 33555147!goToNextLesson  self next! !ProfStef class removeSelector: #goToNextLesson!!PharoSyntaxTutorial methodsFor: 'interactive' stamp: 'georg 1/22/2020 17:35' prior: 55571434!divideTwoByZero		"Oops!! 2/0 raises a ZeroDivide exception. So the debugger opens to let you fix the code.	- Remove the line of code above.	- Right-click and select 'Accept' to compile the new version of the method	- click the button 'Proceed' to continue execution."	ProfStef next. ! !----QUIT----2020-01-22T17:36:01.320876-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 387!----QUIT----2020-01-22T17:37:22.816066-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 1312!----QUIT----2020-01-28T11:31:58.994578-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 1409!Object subclass: #Poker	instanceVariableNames: ''	classVariableNames: ''	package: 'LAB'!Object subclass: #Poker	instanceVariableNames: 'first scnd'	classVariableNames: ''	package: 'LAB'!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/19/2020 15:41'!deal:  cards! !Object subclass: #Poker	instanceVariableNames: 'frsthnd scndhnd'	classVariableNames: ''	package: 'LAB'!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/19/2020 16:15' prior: 33556307!deal:  cardsfrsthnd := cards  selectEveryFirst.scndhnd := cards selectEverySecond.Transcript show: frsthnd ;frsthnd; cr.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/19/2020 16:18' prior: 33556520!deal:  cardsfrsthnd := cards  selectEveryFirst.scndhnd := cards selectEverySecond.^frsthnd! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/19/2020 16:19' prior: 33556738!deal:  cardsfrsthnd := cards  selectEveryFirst.scndhnd := cards selectEverySecond.^frsthnd value ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/19/2020 16:20' prior: 33556926!deal:  cardsfrsthnd := cards  selectEveryFirst.scndhnd := cards selectEverySecond.^frsthnd ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/19/2020 16:20' prior: 33557121!deal:  cardsfrsthnd := cards  selectEveryFirst.scndhnd := cards selectEverySecond.^frsthnd asArray ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/19/2020 16:21' prior: 33557310!deal:  cardsfrsthnd := cards  selectEveryFirst.scndhnd := cards selectEverySecond.^frsthnd asOrderedCollection ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/19/2020 16:22' prior: 33557507!deal:  cardsfrsthnd := cards  selectEveryFirst.scndhnd := cards selectEverySecond.^frsthnd asSortedCollection asArray ! !----SNAPSHOT----2020-02-19T16:28:19.328202-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 1507!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 10:26' prior: 33557716!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection asArray.scndhnd := cards selectEverySecond asSortedCollection asArray.^frsthnd ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 10:27' prior: 33558034!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection.scndhnd := cards selectEverySecond asSortedCollection asArray.^frsthnd ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 10:28' prior: 33558276!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection asArray.scndhnd := cards selectEverySecond asSortedCollection asArray.^frsthnd ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 10:37'!suit  ^nil! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 12:10' prior: 33558510!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection asArray.^frsthnd ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 12:12'!what: hand  ^nil! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 12:13' prior: 33559074!what: hand  ^hand! !Object subclass: #Poker	instanceVariableNames: 'frsthnd scndhnd frstvalue'	classVariableNames: ''	package: 'LAB'!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 12:16' prior: 33558736!suit  ^ 1 + 1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 12:16' prior: 33559184!what: hand  ^hand.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 12:17' prior: 33559521!what: hand  ^hand value.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 12:21' prior: 33558840!deal:  cards| value |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection asArray.frstvalue := value what: 1 + 1.^frsthnd ! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 12:22'!what  | hand |^hand value.! !Poker removeSelector: #what:!Poker removeSelector: #what!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 13:05'!whatis: card  ^ 1 + 1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 13:06' prior: 33559751!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection asArray.frstvalue :=  frsthnd whatis: frsthnd.^frsthnd ! !Poker removeSelector: #whatis:!Poker removeSelector: #suit!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 13:20'!isFlush: cardscards do: [:a | Transcript show: a printString; cr].! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 13:42' prior: 33560310!deal:  cards| ad |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection asArray.ad := Dictionary new. frsthnd do: [ :a |  a between: 1 and: 13  do: [ ad add: #a->a  ].								 a between: 14 and: 26  do: [ ad add: #c->a ] ].^ad.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:16' prior: 33560809!deal:  cards| ad1 ad |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad1 := Poker suits.frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad1 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad1 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad1 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad1 add: a->4 ]].^ad.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:18' prior: 33561210!deal:  cards| ad1 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad1 := frsthnd  suits.frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad1 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad1 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad1 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad1 add: a->4 ]].^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:19' prior: 33561772!deal:  cards| ad1 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad1 := Poker suits: frsthnd .frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad1 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad1 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad1 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad1 add: a->4 ]].^ad1.! !Poker class	instanceVariableNames: 'frsthnd scndhnd frstvalue'!!Poker class methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:26'!deal:  cards| ad1 ad2 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad1 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad1 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad1 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad1 add: a->4 ]].frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad2 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad2 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad2 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad2 add: a->4 ]].												^ad1.! !Poker removeSelector: #deal:!Poker removeSelector: #isFlush:!Poker class	instanceVariableNames: 'frsthnd scndhnd frstvalue ad1 ad2 '!!Poker class methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:28' prior: 33562961!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad1 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad1 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad1 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad1 add: a->4 ]].frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad2 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad2 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad2 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad2 add: a->4 ]].												^ad1.! !!Poker class methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:28'!suit frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad1 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad1 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad1 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad1 add: a->4 ]].							! !!Poker class methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:28'!suitsafrsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad1 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad1 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad1 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad1 add: a->4 ]].							! !!Poker class methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:29' prior: 33563939!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := frsthnd suitsa.												^ad1.! !Poker class removeSelector: #suit!!Poker class methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:31' prior: 33565465!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := frsthnd suitsa.ad2 := scndhnd suitsa.												^ad1.! !Object subclass: #Poker	instanceVariableNames: 'frsthnd scndhnd frstvalue ad1 ad2'	classVariableNames: ''	package: 'LAB'!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:37'!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := frsthnd suitsa.ad2 := scndhnd suitsa.												^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:37'!suitsafrsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ ad1 add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ ad1 add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ ad1 add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ ad1 add: a->4 ]].							! !Poker class removeSelector: #deal:!Poker class removeSelector: #suitsa!Poker class	instanceVariableNames: ''!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:39' prior: 33566672!suitsa| add |add := Dictionary new.frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ add add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ add add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ add add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ add add: a->4 ]].							! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:39' prior: 33567148!suitsa| add |add := Dictionary new.frsthnd do: [ :a |  (a between: 1 and: 13) ifTrue: [ add add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ add add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ add add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ add add: a->4 ]].^add.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:43'!suitsa: hand| add |add := Dictionary new.hand do: [ :a |  (a between: 1 and: 13) ifTrue: [ add add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ add add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ add add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ add add: a->4 ]].^add.! !Poker removeSelector: #suitsa!!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:48' prior: 33566324!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := Poker suitsa: frsthnd .ad2 := Poker suitsa: scndhnd.												^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:49' prior: 33568336!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1  suitsa: frsthnd .ad2 := Poker suitsa: scndhnd.												^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 14:49' prior: 33568715!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1  suitsa: frsthnd .ad2 suitsa: scndhnd.												^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 15:02' prior: 33569086!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := Poker suitsa: frsthnd .												^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 15:02' prior: 33569448!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .												^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 15:43' prior: 33567912!suitsa: hand| add |add := Dictionary new.hand do: [ :a |     (a between: 1 and: 13) ifTrue: [ add add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ add add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ add add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ add add: a->4 ]].^add.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 15:43' prior: 33569798!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .((ad1  at: 5) == 1) ifTrue: [ ad1 swap: 1 with: 5  ].												^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 15:52' prior: 33570542!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									Transcript show:  [   ad1 occurrencesOf: 3 ] value .^ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 16:05'!isFlush: cards| y b c |y := cards values. b := y at: 1.c := True.y do: [ :a | (b == a) ifFalse: (c := False) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:05' prior: 33571387!isFlush: cards| y b c |y := cards values. b := y at: 1.c := true.y do: [ :a | (b == a) ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 16:06' prior: 33570976!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									^self isFlush: ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 16:07' prior: 33571813!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									^self isFlush: ad1 ; ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 16:08' prior: 33572201!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									^self isFlush: ad1, ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 16:09' prior: 33572596!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									Transcript show: ad1.^self isFlush: ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 16:09' prior: 33572990!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									Transcript show: ad1; cr.^self isFlush: ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 16:09' prior: 33573400!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									Transcript show: ad1; cr.^self isFlush: ad1.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:10' prior: 33571594!isFlush: cards| y b c |y := cards keys. b := y at: 1.c := true.y do: [ :a | (b == a) ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:10' prior: 33574216!isFlush: cards| y b c |y := cards values. b := y at: 1.c := true.y do: [ :a | (b == a) ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:11' prior: 33574421!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | (b == a) ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:12' prior: 33574628!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | (b = a) ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:12' prior: 33574858!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | (b equals:  a) ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:13' prior: 33575087!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | (b equalBlock:   a) ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:14' prior: 33575323!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | [ a == b ] ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:14' prior: 33575564!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | [ a == b ] value  ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:14' prior: 33575796!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | [ a = b ] value  ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:15' prior: 33576035!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true."y do: [ :a | [ a = b ] value  ifFalse: (c := false) ]."^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:15' prior: 33576273!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | [ a = b ] value  ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:17' prior: 33576513!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1.c := true.y do: [ :a | ( a = b )  ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:17' prior: 33576751!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1. Transcript show: b; cr.c := true.y do: [ :a | ( a = b )  ifFalse: (c := false) ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:18' prior: 33576983!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1. Transcript show: b; cr.c := true.y do: [ :a | ( a = b )  ifFalse: [c := false] ].^c.! !----SNAPSHOT----2020-02-21T16:20:10.502202-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 3410!!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:30' prior: 33577241!isFlush: cards| y b c |y := cards values. Transcript show: y; cr.b := y at: 1. Transcript show: b; cr.c := true.y do: [ :a | ( a = b )  ifFalse: [c := false] ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:30' prior: 33577601!isFlush: cards| y b c |y := cards values. "Transcript show: y; cr."b := y at: 1. "Transcript show: b; cr."c := true.y do: [ :a | ( a = b )  ifFalse: [c := false] ].^c.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 16:30' prior: 33577857!isFlush: cards| y b c |y := cards values.            "Transcript show: y; cr."b := y at: 1.            "Transcript show: b; cr."c := true.y do: [ :a | ( a = b )  ifFalse: [c := false] ].^c.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 16:56' prior: 33570147!suitsa: hand| add |add := Dictionary new.hand do: [ :a |     (a between: 1 and: 13) ifTrue: [ add add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ add add: (a-13)->2 ].								 (a between: 27 and: 39) ifTrue: [ add add: (a-26)->3 ].								 (a between: 40 and: 52) ifTrue: [ add add: (a-39)->4 ]].^add.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 17:12' prior: 33578411!suitsa: hand| add |add := Dictionary new.hand do: [ :a |     (a between: 1 and: 13) ifTrue: [ add add:  a->1 ].								 (a between: 14 and: 26) ifTrue: [ add add: a->2 ].								 (a between: 27 and: 39) ifTrue: [ add add: a->3 ].								 (a between: 40 and: 52) ifTrue: [ add add: a->4 ]].^add.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 17:25'!isStrght: hand | key temp |temp := Array newFrom: hand .temp do: [ :a |     (a between: 14 and: 26) ifTrue: [ a-13 ].								 (a between: 27 and: 39) ifTrue: [ a-26 ].								 (a between: 40 and: 52) ifTrue: [ a-39 ]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:25' prior: 33579200!isStrght: hand |  temp |temp := Array newFrom: hand .temp do: [ :a |     (a between: 14 and: 26) ifTrue: [ a-13 ].								 (a between: 27 and: 39) ifTrue: [ a-26 ].								 (a between: 40 and: 52) ifTrue: [ a-39 ]].^temp! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 17:26' prior: 33573814!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									Transcript show: ad1; cr.^self isStrght: ad1.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 17:27' prior: 33579841!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .									Transcript show: ad1; cr.^self isStrght: frsthnd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:29' prior: 33579516!isStrght: hand |  temp |temp := Array newFrom: hand .temp do: [ :a |     (a between: 14 and: 26) ifTrue: [  a = a].								 (a between: 27 and: 39) ifTrue: [ a = a-26 ].								 (a between: 40 and: 52) ifTrue: [ a = a-39 ]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:29' prior: 33580664!isStrght: hand |  temp |temp := Array newFrom: hand .temp do: [ :a |     (a between: 14 and: 26) ifTrue: [  a = a - 13].								 (a between: 27 and: 39) ifTrue: [ a = a-26 ].								 (a between: 40 and: 52) ifTrue: [ a = a-39 ]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:30' prior: 33580986!isStrght: hand |  temp |temp := Array newFrom: hand .temp do: [ :a |     (a between: 14 and: 26) ifTrue: [  a = (a - 13)].								 (a between: 27 and: 39) ifTrue: [ a = (a-26) ].								 (a between: 40 and: 52) ifTrue: [ a = (a-39) ]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:32' prior: 33581313!isStrght: hand |  temp |temp := Array newFrom: hand .temp collect: [ :a | (a between: 14 and: 26) ifTrue: [  a - 13].								  (a between: 27 and: 39) ifTrue: [ a-26 ].								  (a between: 40 and: 52) ifTrue: [ a-39]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:33' prior: 33581646!isStrght: hand |  temp |temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [  a - 13].								  (a between: 27 and: 39) ifTrue: [ a-26 ].								  (a between: 40 and: 52) ifTrue: [ a-39]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:34' prior: 33581963!isStrght: hand |  temp |temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [(a - 13)].								            (a between: 27 and: 39) ifTrue: [ (a-26 )].								            (a between: 40 and: 52) ifTrue: [ (a-39) ]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:34' prior: 33582261!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [(a - 13)].								            (a between: 27 and: 39) ifTrue: [ (a-26 )].								            (a between: 40 and: 52) ifTrue: [ (a-39) ]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:35' prior: 33582584!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ 23 ].								            (a between: 27 and: 39) ifTrue: [ 1].								            (a between: 40 and: 52) ifTrue: [ 2 ]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:44' prior: 33582928!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ a - 13 ].								            (a between: 27 and: 39) ifTrue: [ a - 26 ].								            (a between: 40 and: 52) ifTrue: [ a - 39 ]].^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:44' prior: 33583257!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ a - 13 ].								            (a between: 27 and: 39) ifTrue: [ a - 26 ].								            (a between: 40 and: 52) ifTrue: [ a - 39 ]].Transcript show: temp; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:45' prior: 33583598!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue:  a - 13 .								            (a between: 27 and: 39) ifTrue:  a - 26 .								            (a between: 40 and: 52) ifTrue:  a - 39 ].Transcript show: temp; cr.^temp! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 17:46' prior: 33580256!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .	Transcript show: frsthnd ; cr.^self isStrght: frsthnd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:46' prior: 33583965!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | 1].Transcript show: temp; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:47' prior: 33584743!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | a between: 14 and: 26 ifTrue: [ a - 13 ].								            a between: 27 and: 39 ifTrue: [ a - 26 ].								            a between: 40 and: 52 ifTrue: [ a - 39 ]].Transcript show: temp; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:47' prior: 33584941!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | [a between: 14 and: 26] ifTrue: [ a - 13 ].								            [a between: 27 and: 39] ifTrue: [ a - 26 ].								            [a between: 40 and: 52] ifTrue: [ a - 39 ]].Transcript show: temp; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:47' prior: 33585302!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | [a between: 14 and: 26] value ifTrue: [ a - 13 ].								            [a between: 27 and: 39] value ifTrue: [ a - 26 ].								            [a between: 40 and: 52] value ifTrue: [ a - 39 ]].Transcript show: temp; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:48' prior: 33585669!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ a = (a - 13) ].								            (a between: 27 and: 39) ifTrue: [ a = (a - 26) ].								            (a between: 40 and: 52) ifTrue: [ a = (a - 39) ]].Transcript show: temp; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:51' prior: 33586054!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ].								            (a between: 27 and: 39) ifTrue: [ (a - 26) ].								            (a between: 40 and: 52) ifTrue: [  (a - 39) ]].Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:51' prior: 33586439!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | a + a].Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:52' prior: 33586813!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ].								            (a between: 27 and: 39) ifTrue: [ (a - 26) ].								            (a between: 40 and: 52) ifTrue: [  (a - 39) ]].Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:52' prior: 33587015!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ]value.								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] value.								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] value].Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:54' prior: 33587389!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ 0 ].								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] .								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] ].Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:59' prior: 33587780!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ] ||								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] .								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] ].Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 17:59' prior: 33588149!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 0 and: 100) ifTrue: [ 0 ] .								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] .								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] ].Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:00' prior: 33588527!isStrght: hand |  temp |temp := Array new: 5.temp :=  hand collect:  [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ] .								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] .								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] ].Transcript show: temp; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:01' prior: 33588897!isStrght: hand |  temp |temp := hand.temp :=  temp do:  [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ] .								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] .								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] ].Transcript show: temp; cr.Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:02' prior: 33589274!isStrght: hand |  temp |temp :=  hand collect:   [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ] .								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] .								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] ].Transcript show: temp; cr.Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:02' prior: 33589665!isStrght: hand |  temp |temp :=  hand collect:   [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ] .								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] .								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:03' prior: 33590049!isStrght: hand |  temp |temp :=  hand collect:   [ :a | (a between: 14 and: 26) ifTrue: [ (a - 13) ] .								            (a between: 27 and: 39) ifTrue: [ (a - 26) ] .								            (a between: 40 and: 52) ifTrue: [  (a - 39) ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:03' prior: 33590441!isStrght: hand |  temp |temp :=  hand collect:   [ :a | (a between: 14 and: 26) ifTrue: [ a - 13 ] .								            (a between: 27 and: 39) ifTrue: [ a - 26 ] .								            (a between: 40 and: 52) ifTrue: [  a - 39 ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:06' prior: 33590834!isStrght: hand |  temp |temp = hand copy .temp :=  temp do:      [ :a | (a between: 14 and: 26) ifTrue: [ a - 13 ] .								           (a between: 27 and: 39) ifTrue: [ a - 26 ] .								           (a between: 40 and: 52) ifTrue: [  a - 39 ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:06' prior: 33591221!isStrght: hand |  temp |temp = Array new:5.temp = hand copy .temp :=  temp do:      [ :a | (a between: 14 and: 26) ifTrue: [ a - 13 ] .								           (a between: 27 and: 39) ifTrue: [ a - 26 ] .								           (a between: 40 and: 52) ifTrue: [  a - 39 ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:06' prior: 33591622!isStrght: hand |  temp |temp = hand copy .temp :=  temp do:      [ :a | (a between: 14 and: 26) ifTrue: [ a - 13 ] .								           (a between: 27 and: 39) ifTrue: [ a - 26 ] .								           (a between: 40 and: 52) ifTrue: [  a - 39 ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:08' prior: 33592042!isStrght: hand |  temp |temp = hand copy .temp :=  temp do:      [ :a | (a between: 14 and: 26) ifTrue: [ a =   ( a - 13 )] .								           (a between: 27 and: 39) ifTrue: [ a = (a - 26) ] .								           (a between: 40 and: 52) ifTrue: [ a = ( a - 39 ) ]] .							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:09' prior: 33592444!isStrght: hand |  temp |temp = hand copy .temp :=  temp collect:      [ :a | (a between: 14 and: 26) ifTrue: [   a - 13 ] .								           (a between: 27 and: 39) ifTrue: [ a - 26 ] .								           (a between: 40 and: 52) ifTrue: [  a - 39 ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:11' prior: 33592868!isStrght: hand |  temp |temp :=  hand collectAll: [ :a | (a between: 14 and: 26)     ifTrue: [   a - 13 ] .								               (a between: 27 and: 39)      ifTrue: [ a - 26 ] .								               (a between: 40 and: 52)      ifTrue: [  a - 39 ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:12' prior: 33593277!isStrght: hand |  temp |temp :=  hand collect: [ :a | (a between: 14 and: 26)     ifTrue: [   a - 13 ] .								               (a between: 27 and: 39)      ifTrue: [ a - 26 ] .								               (a between: 40 and: 52)      ifTrue: [  a - 39 ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:13' prior: 33593688!isStrght: hand |  temp |temp :=  hand collect: [ :a |     ( a between: 14 and: 26 )     ifTrue: [   a - 13 ] .								               ( a between: 27 and: 39 )      ifTrue: [ a - 26 ] .								               ( a between: 40 and: 52 )      ifTrue: [  a - 39 ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:15' prior: 33594096!isStrght: hand |  temp |temp :=  hand collect: [ :a |     ( a between: 14 and: 26 )     ifTrue: [   a  ] .								               ( a between: 27 and: 39 )      ifTrue: [ a  ] .								               ( a between: 40 and: 52 )      ifTrue: [  a ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:17' prior: 33594514!isStrght: hand |  temp |temp := hand copy .temp :=  temp do: [ :a |     ( a between: 14 and: 26 ) ifTrue: [   a  ] .								               ( a between: 27 and: 39 ) ifTrue: [ a  ] .								               ( a between: 40 and: 52 ) ifTrue: [  a ] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:18' prior: 33594919!isStrght: hand |  temp |temp := hand copy .temp :=  temp do: [ :a |     ( a between: 14 and: 26 ) ifTrue: [  a -13  ] .								               ( a between: 27 and: 39 ) ifTrue: [ a  - 24 ] .								               ( a between: 40 and: 52 ) ifTrue: [  a  - 500] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:19' prior: 33595324!isStrght: hand |  temp |temp := hand copy .temp :=  temp do: [ :a |     ( a between: 14 and: 26 ) ifTrue: [ a put:  a -13  ] .								               ( a between: 27 and: 39 ) ifTrue: [ a  - 24 ] .								               ( a between: 40 and: 52 ) ifTrue: [  a  - 500] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:21' prior: 33595743!isStrght: hand |  temp |temp := hand copy .temp :=  temp timesRepeat:  [ :a |     ( a between: 14 and: 26 ) ifTrue: [ a put:  a -13  ] .								               ( a between: 27 and: 39 ) ifTrue: [ a  - 24 ] .								               ( a between: 40 and: 52 ) ifTrue: [  a  - 500] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:21' prior: 33596169!isStrght: hand |  temp a |temp := hand copy .temp :=  temp timesRepeat:  [      ( a between: 14 and: 26 ) ifTrue: [ a put:  a -13  ] .								               ( a between: 27 and: 39 ) ifTrue: [ a  - 24 ] .								               ( a between: 40 and: 52 ) ifTrue: [  a  - 500] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:22' prior: 33596604!isStrght: hand |  temp |temp := hand copy .temp :=  temp timesRepeat:  [      ( a between: 14 and: 26 ) ifTrue: [ a put:  a -13  ] .								               ( a between: 27 and: 39 ) ifTrue: [ a  - 24 ] .								               ( a between: 40 and: 52 ) ifTrue: [  a  - 500] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:22' prior: 33597037!isStrght: hand |  temp |temp := hand copy .temp :=  temp timesRepeat:  [      ( a between: 14 and: 26 ) ifTrue: [ a put:  a -13  ] .								               ( a between: 27 and: 39 ) ifTrue: [ a  - 24 ] .								               ( a between: 40 and: 52 ) ifTrue: [  a  - 500] ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:24' prior: 33597468!isStrght: hand |  temp index|temp := hand copy .index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ a put:  a -13  ] .								               ( a between: 27 and: 39 ) ifTrue: [ a  - 24 ] .								               ( a between: 40 and: 52 ) ifTrue: [  a  - 500] .								                index := index + 1 ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!ManifestLAB commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/21/2020 18:25'!ruleRBWhileTrueRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/21/2020 18:25' prior: 33598642!ruleRBWhileTrueRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #isStrght: #false)) #'2020-02-21T18:25:23.820202-05:00') )! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/21/2020 18:25' prior: 33598781!ruleRBWhileTrueRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #isStrght: #false)) #'2020-02-21T18:25:23.820202-05:00') #(#(#RGClassDefinition #(#Poker)) #'2020-02-21T18:25:29.118202-05:00') )! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:26' prior: 33597899!isStrght: hand |  temp index|temp := hand copy .index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put:  (a -13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a  - 24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a  - 500)] .								                index := index + 1 ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:27' prior: 33599293!isStrght: hand |  temp index|temp := hand copy .index := 1.[ index < hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].							Transcript show: temp; cr.Transcript show: hand; cr.^temp.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 18:29'!switch: cards| index hand temp |index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].							^index.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 18:29' prior: 33600503!switch: cards| index hand temp |index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].							^cards.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 18:30' prior: 33601047!switch: hand| index temp cards |index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].							^cards.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 18:30' prior: 33601591!switch: hand| index temp cards |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].							^cards.! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/21/2020 18:30' prior: 33602135!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].							^temp.! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:32' prior: 33599905!isStrght: hand | ordered |ordered := self switch: hand .							Transcript show: ordered; cr.Transcript show: hand; cr.^ordered .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:34' prior: 33603248!isStrght: hand | ordered |ordered := self switch: hand .^ordered .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:55' prior: 33603467!isStrght: hand | ordd   b|a := false.b := false.ordd := self switch: hand .[(ordd at: 5) = 1 ] ifTrue: [ [((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)] ifTrue: [ a := true ] ].[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]].^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:56' prior: 33603622!isStrght: hand | ordd   b|a := false.b := false.ordd := self switch: hand .((ordd at: 5) = 1 ) ifTrue: [ [((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)] ifTrue: [ a := true ] ].[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]].^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:56' prior: 33604256!isStrght: hand | ordd   b|a := false.b := false.ordd := self switch: hand .[(ordd at: 5) = 1 ] ifTrue: [ [((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)] value ifTrue: [ a := true ] ].[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]].^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:56' prior: 33604890!isStrght: hand | ordd   b|a := false.b := false.ordd := self switch: hand .[(ordd at: 5) = 1 ] value ifTrue: [ [((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)] value ifTrue: [ a := true ] ].[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]].^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:57' prior: 33605530!isStrght: hand | ordd   b|a := false.b := false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [ [((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)]  ifTrue: [ a := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:57' prior: 33606176!isStrght: hand | ordd   b|a := false.b := false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [[((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)]  ifTrue: [ a := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:58' prior: 33606814!isStrght: hand | ordd  |a := false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [[((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)]  ifTrue: [ a := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:58' prior: 33607451!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [[((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)]  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:59' prior: 33608075!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [[((ordd at: 1) = 5) &&	                            ((ordd at: 2) = 4) &&	                            ((ordd at: 3) = 3) && 	                            ((ordd at: 4) = 2)  ]  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:59' prior: 33608701!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [[((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  ]  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 18:59' prior: 33609330!isStrght: hand | ordd  q |q = false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [[((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  ]  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 19:00' prior: 33609955!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [[((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  ]  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'testing' stamp: 'georg 2/21/2020 19:00' prior: 33610579!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .[(ordd at: 5) = 1 ]  ifTrue: [[((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  ]  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:02' prior: 33611204!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [[((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  ]  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:02' prior: 33611826!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^ordd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:03' prior: 33612448!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:05' prior: 33613070!isStrght: hand | ordd  q |q := false.ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:06' prior: 33602701!switch: hand| index temp |Transcript show: hand; cr.temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].							^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:07' prior: 33614335!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].Transcript show: temp sthnd ; cr.		^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:07' prior: 33614905!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].Transcript show: temp  ; cr.		^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:07' prior: 33615477!switch: hand| index temp |index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:07' prior: 33616044!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-24) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-500)] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:08' prior: 33616593!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a-13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a-26) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a-39)] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:08' prior: 33617163!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: (a - 13)  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: (a - 26) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: (a - 39)] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:08' prior: 33617732!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 )] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:08' prior: 33618307!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:11' prior: 33613689!isStrght: hand | ordd  q |q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:11' prior: 33618888!switch: hand| index temp |temp := Array new: 5.index := 1.Transcript show: temp  ; cr.	[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:11' prior: 33620119!switch: hand| index temp |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:14' prior: 33620731!switch: hand| index temp aq |temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !Object subclass: #Poker	instanceVariableNames: 'frsthnd scndhnd frstvalue ad1 ad2'	classVariableNames: ''	package: 'LAB'!!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:15' prior: 33621314!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !Object subclass: #Poker	instanceVariableNames: 'frsthnd scndhnd ad1 ad2'	classVariableNames: ''	package: 'LAB'!!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:17' prior: 33619470!isStrght: hand | ordd  q |q := false .ordd := self switch: hand .Transcript show: hand ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ]."[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ a := true ]]."^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:19' prior: 33622026!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:21' prior: 33623375!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index). Transcript show: 'hi'  ; cr.	                                  ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:21' prior: 33623959!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index). Transcript show: a .                                   ( a between: 14 and: 26 ) ifTrue: [ temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:22' prior: 33624573!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                   ( a between: 14 and: 26 ) ifTrue: [Transcript show: temp  ; cr.  temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:22' prior: 33625179!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index).                                   ( a between: 14 and: 26 ) ifTrue: [Transcript show: 'temp'  ; cr.  temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:23' prior: 33625793!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index). 	                                ( a between: 14 and: 26 ) ifTrue: [temp at: index put: ( a )  ] .                                  ( a between: 14 and: 26 ) ifTrue: [temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:23' prior: 33626409!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index). 	                                ( a between: 1 and: 13 ) ifTrue: [temp at: index put: ( a )  ] .                                  ( a between: 14 and: 26 ) ifTrue: [temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].Transcript show: temp  ; cr.				^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:24' prior: 33622726!isStrght: hand | ordd  q |q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ].[(ordd at: 1) = 1 ] ifTrue: [ [((ordd at: 2) = 10) &&	                            ((ordd at: 3) = 11) &&	                            ((ordd at: 4) = 12) && 	                            ((ordd at: 5) = 13)] ifTrue: [ q := true ]].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:25' prior: 33627774!isStrght: hand | ordd  q |q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ].((ordd at: 1) = 1 ) ifTrue:  [(((ordd at: 2) = 10) &	                            ((ordd at: 3) = 11) &	                            ((ordd at: 4) = 12) & 	                            ((ordd at: 5) = 13)) ifTrue: [ q := true ]].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:26' prior: 33628421!isStrght: hand | ordd  q |q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 10) &	                            ((ordd at: 2) = 11) &	                            ((ordd at: 3) = 12) & 	                            ((ordd at: 4) = 13)) ifTrue: [ q := true ]].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:26' prior: 33629065!isStrght: hand | ordd  q |q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 2) = 13) &	                            ((ordd at: 3) = 12) &	                            ((ordd at: 4) = 11) & 	                            ((ordd at: 5) = 10)) ifTrue: [ q := true ]].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:27' prior: 33629709!isStrght: hand | ordd  q |q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ q := true ]].^q .! !----SNAPSHOT----2020-02-21T19:27:32.057202-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 22989!!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:33' prior: 33630353!isStrght: hand | ordd  q  t|q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ q := true ]].t := (ordd at: 5) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[q := true ]. t := t - 1.  ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:36' prior: 33631100!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifFalse: [ q := false ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifFalse: [ q := false ]].t := (ordd at: 5) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:36' prior: 33631836!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifFalse: [ q := false ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifFalse: [ q := false ]].t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:37' prior: 33632577!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifFalse: [ q := false ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifFalse: [ q := false ]]."t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ]."^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:38' prior: 33633318!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifFalse: [ q := false ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifFalse: [ q := false ]].t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:39' prior: 33634061!isStrght: hand | ordd  q  t|q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := false ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ q := false ]].t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:39' prior: 33634802!isStrght: hand | ordd  q  t|q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ].((ordd at: 5) = 1 ) ifTrue:  [(((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ q := true ]].t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:41' prior: 33635542!isStrght: hand | ordd  q  t|q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ [(((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] ]  | [                                 (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ q := true ] ]].t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:45' prior: 33636280!isStrght: hand | ordd  q  t|q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ ((((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ q := true ] )   |  (                                 (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ q := true ] ) ]  ifFalse: [  t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:46' prior: 33637029!isStrght: hand | ordd  q  t|q := false .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ ((((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] )   |  (                                 (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ q := true ] ) ]  ifFalse: [  t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:48' prior: 33637796!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1) - 1 .ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:50' prior: 33638559!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1) - 1 .Transcript show: t ; cr.ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:50' prior: 33639303!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1).Transcript show: t ; cr.ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 19:51' prior: 33640071!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !----SNAPSHOT----2020-02-21T19:51:58.804202-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 76490!!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:01'!strtflush: hand ( self isFlush: hand & self isStrght: hand ) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:01' prior: 33641631!strtflush: hand ( (self isFlush: hand) & (self isStrght: hand) ) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:01' prior: 33584338!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .	Transcript show: frsthnd ; cr.^self strtflush:  frsthnd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:06' prior: 33578117!isFlush: cards| y b c temp |temp := self suitsa: frsthnd .y := temp values.            "Transcript show: y; cr."b := y at: 1.            "Transcript show: b; cr."c := true.y do: [ :a | ( a = b )  ifFalse: [c := false] ].^c.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:06' prior: 33642375!isFlush: cards| y b c temp |temp := self suitsa: cards .y := temp values.            "Transcript show: y; cr."b := y at: 1.            "Transcript show: b; cr."c := true.y do: [ :a | ( a = b )  ifFalse: [c := false] ].^c.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:12'!rylflush: hand| temp |temp := self suitsa: hand  .( (self isFlush: hand ) & (self isStrght: hand) ) & ( (temp at: 1) = 1 ) ifTrue: [ ^true ]. ! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:12' prior: 33642987!rylflush: hand| temp |temp := self suitsa: hand  .( (self isFlush: hand ) & (self isStrght: hand) ) & ( (temp at: 1) = 1 ) ifTrue: [ ^true ]. ^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:12' prior: 33643212!rylflush: hand| temp |temp := self suitsa: hand  .( (self isFlush: hand ) & (self isStrght: hand) ) & ( (temp at: 5) = 1 ) ifTrue: [ ^true ]. ^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:12' prior: 33641971!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .	Transcript show: frsthnd ; cr.^self rylflush:  frsthnd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:13' prior: 33643446!rylflush: hand| temp |temp := self switch: hand  .( (self isFlush: hand ) & (self isStrght: hand) ) & ( (temp at: 5) = 1 ) ifTrue: [ ^true ]. ^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:18' prior: 33644083!rylflush: hand| temp |temp := self switch: hand  .( (self isFlush: hand ) & (self isStrght: hand) ) & ( (temp at: 5) = 1 ) & ( (temp at: 1) = 10 )ifTrue: [ ^true ]. ^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:28'!furkind: cards | temp  c |temp := self switch: cards .c := temp at: 1.temp do: [ :a | ( c = a ) ifFalse: [ ^false ] ] .^true.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:28' prior: 33644560!furkind: cards | temp  c |temp := self switch: cards .c := temp at: 1.temp do: [ :a | ( c = a ) ifFalse: [ ^false ] ] .^true.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:32' prior: 33644773!furkind: cards | temp  c |temp := self switch: cards .c := temp at: 1.( (temp at: 1) = temp at: 2 = temp at: 3 = temp at: 4 ) ifTrue: [ ^true ].^true.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:32' prior: 33644987!furkind: cards | temp  c |temp := self switch: cards .c := temp at: 1.( (temp at: 1) = (temp at: 2 ) = (temp at: 3) = (temp at: 4 )) ifTrue: [ ^true ].^true.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:33' prior: 33645226!furkind: cards | temp  c |temp := self switch: cards .c := temp at: 1.( (temp at: 1) = (temp at: 2 ) = (temp at: 3) = (temp at: 4 )) ifTrue: [ ^true ].( (temp at: 2) = (temp at: 3 ) = (temp at: 4) = (temp at: 5 )) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:33' prior: 33643680!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .	Transcript show: frsthnd ; cr.^self furkind:   frsthnd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:35' prior: 33645472!furkind: cards | temp  c |temp := self switch: cards .c := temp at: 1.( (temp at: 1) = (temp at: 2 ) & (temp at: 3) = (temp at: 4 )) ifTrue: [ ^true ].( (temp at: 2) = (temp at: 3 ) & (temp at: 4) & (temp at: 5 )) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:36' prior: 33646203!furkind: cards | temp |temp := self switch: cards .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( (temp at: 2) = (temp at: 3 ) & (temp at: 4) & (temp at: 5 )) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:39' prior: 33646533!furkind: cards | temp |temp := self switch: cards .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:40' prior: 33646848!furkind: cards | temp |temp := self switch: cards sorted .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:41' prior: 33647167!furkind: cards | temp |temp := self switch: cards asSortedCollection .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:43' prior: 33647490!furkind: cards | temp |temp := self switch: cards asSortedCollection reverse asArray .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:43' prior: 33647825!furkind: cards | temp |temp := self switch: cards asSortedCollection  asArray .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:44' prior: 33648176!furkind: cards | temp |temp := self switch: cards .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:47' prior: 33648520!furkind: cards | temp |temp := (self switch: cards) asSortedCollection  .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:48' prior: 33648836!furkind: cards | temp |temp := (self switch: cards) asSortedCollection reverse   .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 20:48' prior: 33649174!furkind: cards | temp |temp := (self switch: cards) asSortedCollection   .Transcript show: temp ; cr.( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !----SNAPSHOT----2020-02-21T20:49:39.540202-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 87037!!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 21:53'!fullHuse: cards| temp |temp := (self switch: cards) asSortedCollection .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 1) = (temp at: 3 )) 														& ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].														( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3)) 														& ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].														^false.														! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 21:54' prior: 33649975!fullHuse: cards| temp |temp := (self switch: cards) asSortedCollection .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 )) 														& ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].														( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4)) 														& ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].														^false.														! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 21:56' prior: 33645800!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .	Transcript show: frsthnd ; cr.^self fullHuse:    frsthnd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:01'!threekind: card| temp cards |temp := (self switch: cards) asSortedCollection .(( self furkind: card ) | ( self fullHuse: card )) ifTrue: [ ^false ]! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:01' prior: 33651316!threekind: cards| temp |temp := (self switch: cards) asSortedCollection .(( self furkind: cards ) | ( self fullHuse: cards )) ifTrue: [ ^false ]! !----SNAPSHOT----2020-02-21T22:03:30.281202-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 95381!!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:05' prior: 33651550!threekind: cards| temp |temp := (self switch: cards) asSortedCollection .(( self furkind: cards ) | ( self fullHuse: cards )) ifTrue: [ ^false ].( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 3) = (temp at: 4 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:10' prior: 33651887!threekind: cards| temp |temp := (self switch: cards) asSortedCollection .(( self furkind: cards ) | ( self fullHuse: cards )) ifTrue: [ ^false ].Transcript show: temp ; cr. ( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 3) = (temp at: 4 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:11' prior: 33652385!threekind: cards| temp |temp := (self switch: cards) asSortedCollection .(( self furkind: cards ) | ( self fullHuse: cards )) ifTrue: [ ^false ].Transcript show: temp ; cr. ( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 3) = (temp at: 4 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:11' prior: 33650927!deal:  cardsfrsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .	Transcript show: frsthnd ; cr.^self threekind: frsthnd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:12' prior: 33652911!threekind: cards| temp |temp := (self switch: cards) asSortedCollection .(( self furkind: cards ) | ( self fullHuse: cards )) ifTrue: [ ^false ].( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 3) = (temp at: 4 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:25'!twoprs: cards| temp |temp := (self switch: cards) asSortedCollection .(( self fullHuse:  cards ) | ( self furkind:  cards ) | ( self threekind: cards ) ) ifTrue: [ ^false ].( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 3) = (temp at: 4 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:28' prior: 33654322!twoprs: cards| temp |temp := (self switch: cards) asSortedCollection .(( self fullHuse:  cards ) | ( self furkind:  cards ) | ( self threekind: cards ) ) ifTrue: [ ^false ].( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 1) = (temp at: 2 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:29'!onepair: cards| temp |temp := (self switch: cards) asSortedCollection .(( self fullHuse:  cards ) | ( self furkind:  cards ) | ( self threekind: cards )                                                       |  self twoprs: cards ) ifTrue: [ ^false ].( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 1) = (temp at: 2 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:31' prior: 33655356!onepair: cards| temp |temp := (self switch: cards) asSortedCollection .(( self fullHuse:  cards ) | ( self furkind:  cards ) | ( self threekind: cards )                                                       |  self twoprs: cards ) ifTrue: [ ^false ].( ((temp at: 1) = (temp at: 2 )) ) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) ) ifTrue: [ ^true ].( ((temp at: 3) = (temp at: 4 )) ) ifTrue: [ ^true ].( ((temp at: 4) = (temp at: 5 )) ) ifTrue: [ ^true ].^false! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:31' prior: 33655959!onepair: cards| temp |temp := (self switch: cards) asSortedCollection .(( self fullHuse:  cards ) | ( self furkind:  cards ) | ( self threekind: cards )                                                       | (self twoprs: cards ) ) ifTrue: [ ^false ].( ((temp at: 1) = (temp at: 2 )) ) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) ) ifTrue: [ ^true ].( ((temp at: 3) = (temp at: 4 )) ) ifTrue: [ ^true ].( ((temp at: 4) = (temp at: 5 )) ) ifTrue: [ ^true ].^false! !----SNAPSHOT----2020-02-21T22:33:19.893202-05:00 Pharo 8.0 - 32bit (stable).image priorSource: 97277!----SNAPSHOT----2020-02-21T22:33:52.043202-05:00 Pharo 8.0 - 32bit (stable).1.image priorSource: 102576!!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:46'!chk: cards1 nd: cards2! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 22:46' prior: 33653438!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .win := self chk: frsthnd nd: scndhnd .Transcript show: frsthnd ; cr.^self threekind: frsthnd .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:03' prior: 33641799!strtflush: hand ( (self isFlush: hand ) & (self isStrght: hand) ) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:03' prior: 33649521!furkind: cards | temp |temp := (self switch: cards) asSortedCollection   .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:13'!whatme: cards(self rylflush: cards) ifTrue: [ ^1 ].(self strtflush:  cards) ifTrue: [ ^2 ].(self furkind:  cards) ifTrue: [ ^3 ].(self fullHuse:  cards) ifTrue: [ ^4 ].(self isFlush:  cards) ifTrue: [ ^5 ].(self isStrght:  cards) ifTrue: [ ^6 ].(self threekind:  cards) ifTrue: [ ^7 ].(self twoprs:  cards) ifTrue: [ ^8 ].(self onepair:  cards) ifTrue: [ ^9 ].^10! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:14' prior: 33658322!whatme: cards(self rylflush: cards) ifTrue: [ ^1 ].(self strtflush:  cards) ifTrue: [ ^2 ].(self furkind:  cards) ifTrue: [ ^3 ].(self fullHuse:  cards) ifTrue: [ ^4 ].(self isFlush:  cards) ifTrue: [ ^5 ].(self isStrght:  cards) ifTrue: [ ^6 ].(self threekind:  cards) ifTrue: [ ^7 ].(self twoprs:  cards) ifTrue: [ ^8 ].(self onepair:  cards) ifTrue: [ ^9 ].^10! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:16' prior: 33657276!chk: cards1 nd: cards2| f  s d |f := self whatme: cards1.s := self whatme: cards2.(f > s) ifTrue: [ ^f ].(f < s)  ifTrue: [ ^s ].(f = s)  ifTrue: [ d := f ]! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:17' prior: 33659235!chk: cards1 nd: cards2| f  s d |f := self whatme: cards1.s := self whatme: cards2.(f > s) ifTrue: [ ^cards1 ].(f < s)  ifTrue: [ ^cards2  ].(f = s)  ifTrue: [ d := f ].! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:18' prior: 33657376!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .win := self chk: frsthnd nd: scndhnd .Transcript show: frsthnd ; cr.Transcript show: scndhnd  ; cr.^win.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:22' prior: 33659478!chk: cards1 nd: cards2| f  s d |f := self whatme: cards1.s := self whatme: cards2.Transcript show: f ; cr.Transcript show: s; cr.(f > s) ifTrue: [ ^cards1 ].(f < s)  ifTrue: [ ^cards2  ].(f = s)  ifTrue: [ d := f ].! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:24' prior: 33644317!rylflush: hand| temp |temp := self switch: hand  .( (self isFlush: hand ) & (self isStrght: hand) ) & ( (temp at: 5) = 1 ) & ( (temp at: 1) = 13 )ifTrue: [ ^true ]. ^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:25' prior: 33659735!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .win := self chk: frsthnd nd: scndhnd .Transcript show: frsthnd ; cr.Transcript show: scndhnd  ; cr.^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:26' prior: 33660762!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:27' prior: 33627092!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index). 	                                ( a between: 1 and: 13 ) ifTrue: [temp at: index put: ( a )  ] .                                  ( a between: 14 and: 26 ) ifTrue: [temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].			^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:27' prior: 33660197!chk: cards1 nd: cards2| f  s d |f := self whatme: cards1.s := self whatme: cards2.Transcript show: f ; cr.Transcript show: s; cr.(f < s) ifTrue: [ ^cards1 ].(f > s)  ifTrue: [ ^cards2  ].(f = s)  ifTrue: [ d := f ].! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:31' prior: 33661233!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .Transcript show: (self switch: frsthnd) ; cr.Transcript show: (self switch: scndhnd) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:36' prior: 33657999!furkind: cards | temp |temp := (self switch: cards) asSortedCollection   .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 ))                                 & ((temp at: 3) = (temp at: 4 ))) ifTrue: [ ^true ].( ((temp at: 2) = (temp at: 3 )) & ((temp at: 3) = (temp at: 4 ))                                 & ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:41'!tiebrk: numa! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:41' prior: 33662292!chk: cards1 nd: cards2| f  s d |f := self whatme: cards1.s := self whatme: cards2.Transcript show: f ; cr.Transcript show: s; cr.(f < s) ifTrue: [ ^cards1 ].(f > s)  ifTrue: [ ^cards2  ].(f = s)  ifTrue: [ self t].! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:41' prior: 33663643!chk: cards1 nd: cards2| f  s d |f := self whatme: cards1.s := self whatme: cards2.Transcript show: f ; cr.Transcript show: s; cr.(f < s) ifTrue: [ ^cards1 ].(f > s)  ifTrue: [ ^cards2  ].(f = s)  ifTrue: [ self tiebrk: f].! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:47' prior: 33663948!chk: cards1 nd: cards2| f  s d |f := self whatme: cards1.s := self whatme: cards2.Transcript show: f ; cr.Transcript show: s; cr.(f < s) ifTrue: [ ^cards1 ].(f > s)  ifTrue: [ ^cards2  ].(f = s)  ifTrue: [ ^self tiebrk: f].! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:49' prior: 33663551!tiebrk: numa( numa = 1 ) ifTrue: [ ((ad1 value at: 1 ) <  (ad2 value at: 1 )) ifTrue: [ ^frsthnd  ] ] .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:53' prior: 33664575!tiebrk: numa( numa = 1 ) ifTrue: [ ((ad1 at: 1 ) <  (ad2 at: 1 )) ifTrue: [ ^frsthnd  ] ] .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:53' prior: 33662598!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .Transcript show: (self switch: ad1) ; cr.Transcript show: (self switch: scndhnd) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/21/2020 23:58' prior: 33664760!tiebrk: numa( numa = 1 ) ifTrue: [ ((ad1 valueAtStart   ) <  (ad2 valueAtStart )) ifTrue: [ ^frsthnd  ] ] .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:01' prior: 33664933!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .Transcript show: (self switch: frsthnd ) ; cr.Transcript show: (self switch: scndhnd) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:02' prior: 33665428!tiebrk: numa( numa = 1 ) ifTrue: [ ((ad1 valueAt: 1   ) <  (ad2 valueAt: 1 )) ifTrue: [ ^frsthnd  ] ] .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:02' prior: 33666117!tiebrk: numa( numa = 1 ) ifTrue: [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ] ] .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:03' prior: 33664261!chk: cards1 nd: cards2| f  s d |f := self whatme: cards1.s := self whatme: cards2.Transcript show: f ; cr.Transcript show: s; cr.(f < s) ifTrue: [ ^cards1 ].(f > s)  ifTrue: [ ^cards2  ].(f = s)  ifTrue: [ ^(self tiebrk: f)].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:04' prior: 33665617!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .Transcript show: (frsthnd ) ; cr.Transcript show: ( scndhnd) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:05' prior: 33666302!tiebrk: numa( numa = 1 ) ifTrue: [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                                     ifFalse:[ ^scndhnd  ] ] .! !Object subclass: #Poker	instanceVariableNames: 'frsthnd scndhnd ad1 ad2 smpl1 smpl2'	classVariableNames: ''	package: 'LAB'!!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:29' prior: 33666808!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection .smpl1  := (self switch: scndhnd ) asSortedCollection .Transcript show: (smpl1  ) ; cr.Transcript show: ( smpl2 ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:29' prior: 33667695!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection .smpl2  := (self switch: scndhnd ) asSortedCollection .Transcript show: (smpl1  ) ; cr.Transcript show: ( smpl2 ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:30' prior: 33668278!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) .smpl2  := (self switch: scndhnd ) asSortedCollection .Transcript show: (smpl1  ) ; cr.Transcript show: ( smpl2 ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:30' prior: 33668861!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) .smpl2  := (self switch: scndhnd ) .Transcript show: (smpl1  ) ; cr.Transcript show: ( smpl2 ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:32' prior: 33669425!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection asArray.smpl2  := (self switch: scndhnd ) asSortedCollection asArray .Transcript show: (smpl1  ) ; cr.Transcript show: ( smpl2 ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:32' prior: 33669970!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection asArray.smpl2  := (self switch: scndhnd ) asSortedCollection asArray .Transcript show: (smpl1  ) ; cr.Transcript show: ( smpl2 ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:32' prior: 33670568!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection reverse  asArray.smpl2  := (self switch: scndhnd ) asSortedCollection reverse asArray .Transcript show: (smpl1  ) ; cr.Transcript show: ( smpl2 ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:33' prior: 33667283!tiebrk: numa( numa = 1 ) ifTrue: [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                                     ifFalse:[ ^scndhnd  ] ] .(numa = 2 ) ifTrue: [  smpl1   ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:34' prior: 33671779!tiebrk: numa( numa = 1 ) ifTrue: [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                                     ifFalse:[ ^scndhnd  ] ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2)]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:39' prior: 33672098!tiebrk: numa| suitbrk |suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                                     ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2)  ifTrue: [ ^frsthnd  ]	                                                    ifFalse:[ ^scndhnd  ] ] .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:41' prior: 33671165!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection reverse  asArray.smpl2  := (self switch: scndhnd ) asSortedCollection reverse asArray .Transcript show: (smpl1  ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:44' prior: 33672438!tiebrk: numa| suitbrk |suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ]	                                                                  ! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:45' prior: 33673537!tiebrk: numa	| suitbrk |	suitbrk := [ ((ad1 values at: 1) < ad2 values at: 1)		ifTrue: [ ^ frsthnd ]		ifFalse: [ ^ scndhnd ] ].	numa = 1		ifTrue: [ suitbrk value ].	numa = 2		ifFalse: [ ^ self ].	(smpl1 at: 2) < (smpl2 at: 2)		ifTrue: [ ^ frsthnd ].	(smpl1 at: 2) > (smpl2 at: 2)		ifTrue: [ ^ scndhnd ].	suitbrk value! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 00:46' prior: 33674087!tiebrk: numa| suitbrk |suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ]	                                                                  ! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 01:03' prior: 33674495!tiebrk: numa| suitbrk |suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 3) ifTrue: 	[ ((smpl1 at: 1) = (smpl1 at: 2 )) ifTrue: [ ((smpl2 at: 1) = (smpl2 at: 2 ))                                                                              ifTrue: [ (smpl1 at: 1 > smpl2 at: 1) ifTrue: [ ^frsthnd ] .			                                  (smpl1 at: 1 < smpl2 at: 1) ifTrue: [ ^scndhnd  ].			                    ]  ]  suitbrk value.  ]	   																			                                                                  ! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 01:04' prior: 33675045!tiebrk: numa| suitbrk |suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 3) ifTrue: 	[ ((smpl1 at: 1) = (smpl1 at: 2 )) ifTrue: [ ((smpl2 at: 1) = (smpl2 at: 2 ))                                                                              ifTrue: [ (smpl1 at: 1 > smpl2 at: 1) ifTrue: [ ^frsthnd ] .			                                  (smpl1 at: 1 < smpl2 at: 1) ifTrue: [ ^scndhnd  ].			                    ]  ]  suitbrk value.  ].	   																			                                                                  ! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 01:05' prior: 33676009!tiebrk: numa| suitbrk |suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 3) ifTrue: 	[ ((smpl1 at: 1) = (smpl1 at: 2 )) ifTrue: [ ((smpl2 at: 1) = (smpl2 at: 2 ))                                                                              ifTrue: [ (smpl1 at: 1 > smpl2 at: 1) ifTrue: [ ^frsthnd ] .			                                                 (smpl1 at: 1 < smpl2 at: 1) ifTrue: [ ^scndhnd  ].			                    ]  ]  suitbrk value.  ].	   																			                                                                  ! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 01:05' prior: 33676974!tiebrk: numa| suitbrk |suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 3) ifTrue: 	[ ((smpl1 at: 1) = (smpl1 at: 2 )) ifTrue: [ ((smpl2 at: 1) = (smpl2 at: 2 ))                                                                              ifTrue: [ (smpl1 at: 1 > smpl2 at: 1) ifTrue: [ ^frsthnd ] .			                                                 (smpl1 at: 1 < smpl2 at: 1) ifTrue: [ ^scndhnd  ].			                    ]  ]   ].	   																			                                                                  ! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 01:05' prior: 33677954!tiebrk: numa| suitbrk |suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 3) ifTrue: 	[ ((smpl1 at: 1) = (smpl1 at: 2 )) ifTrue: [ ((smpl2 at: 1) = (smpl2 at: 2 ))                                                                              ifTrue: [ (smpl1 at: 1 > smpl2 at: 1) ifTrue: [ ^frsthnd ] .			                                                 (smpl1 at: 1 < smpl2 at: 1) ifTrue: [ ^scndhnd  ].			                     suitbrk value. ]  ]  ].	   																			                                                                  ! !----SNAPSHOT----2020-02-22T01:12:16.522202-05:00 Pharo 8.0 - 32bit (stable).1.image priorSource: 102679!!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 10:46' prior: 33672920!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection reverse  asArray    .smpl2  := (self switch: scndhnd ) asSortedCollection reverse asArray .Transcript show: (smpl1  ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 10:53' prior: 33678919!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :x | x  detect: [ :a  | ((x occurrencesOf: a) = 3 )].	(numa = 3) ifTrue: [   ]  			]		! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 10:54' prior: 33680626!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :x :n| x  detect: [ :a  | ((x occurrencesOf: a) = n )].	(numa = 3) ifTrue: [ occ   ]  			]		! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 11:08' prior: 33681226!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   :frst :scd |  frst = occ  value: smpl1   value: 4 .				].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 11:10' prior: 33681832!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   :frst :scd |  frst = (occ  value: smpl1   value: 4) .				].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 11:11' prior: 33682499!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst | .	                     frst := (occ  value: smpl1   value: 4) .				].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 11:12' prior: 33683168!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .				].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 11:14' prior: 33683857!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].			! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 11:14'!ruleRBLongMethodsRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 11:14' prior: 33685453!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #tiebrk: #false)) #'2020-02-22T11:14:40.031202-05:00') )! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 11:14'!ruleRBGuardingClauseRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 11:14' prior: 33685807!ruleRBGuardingClauseRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #tiebrk: #false)) #'2020-02-22T11:14:42.725202-05:00') )! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 11:14'!ruleGRGuardClauseRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 11:14' prior: 33686167!ruleGRGuardClauseRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #tiebrk: #false)) #'2020-02-22T11:14:50.685202-05:00') )! !----SNAPSHOT----2020-02-22T11:18:46.081202-05:00 Pharo 8.0 - 32bit (stable).1.image priorSource: 125392!!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 11:51' prior: 33684550!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].			].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 11:53' prior: 33686623!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:23' prior: 33688012!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [  ].].	].			! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 12:23'!ruleRBModifiesCollectionRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 12:23' prior: 33691035!ruleRBModifiesCollectionRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #tiebrk: #false)) #'2020-02-22T12:23:23.889202-05:00') )! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:29' prior: 33640836!isStrght: hand | ordd  q  t|q := false .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:29' prior: 33691399!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:31' prior: 33692108!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].Transcript show: q; cr.^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:35' prior: 33692816!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1).Transcript show: t; cr.ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:37' prior: 33693547!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ Transcript show: 12; cr. ] ] ifFalse:[t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:38' prior: 33694280!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ Transcript show: 12; cr.] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] ifFalse:[t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] ].^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:39' prior: 33695009!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:40' prior: 33695737!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .Transcript show: 122; cr.^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:40' prior: 33696438!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .Transcript show: q; cr.^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:44' prior: 33689422!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                       suitbrk value.Transcript show: 'hi'; cr.	].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:44' prior: 33680005!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection reverse  asArray    .smpl2  := (self switch: scndhnd ) asSortedCollection reverse asArray .Transcript show: (smpl1  ) ; cr.Transcript show: ( smpl2   ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:45' prior: 33697164!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:46' prior: 33699578!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection reverse  asArray    .smpl2  := (self switch: scndhnd ) asSortedCollection reverse asArray .Transcript show: (frsthnd   ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:46' prior: 33697888!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                       suitbrk value.	].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:48' prior: 33701522!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].Transcript show: 'hi'; cr.                                   suitbrk value.	].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:49' prior: 33703186!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].Transcript show: 'hi'; cr.                                   suitbrk value.	].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:50' prior: 33704888!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) <  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].Transcript show: 'hi'; cr.                                   suitbrk value.	].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:50' prior: 33706590!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].Transcript show: 'hi'; cr.                                   suitbrk value.	].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 12:55' prior: 33708292!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].			! !----SNAPSHOT----2020-02-22T12:56:35.002202-05:00 Pharo 8.0 - 32bit (stable).1.image priorSource: 132010!----SNAPSHOT----2020-02-22T12:56:39.779202-05:00 Pharo 8.0 - 32bit (stable).2.image priorSource: 157333!----SNAPSHOT----2020-02-22T12:56:50.388202-05:00 Pharo 8.0 - 32bit (stable).3.image priorSource: 157439!----SNAPSHOT----2020-02-22T12:59:46.142202-05:00 Pharo 8.0 - 32bit (stable).3.image priorSource: 157545!----SNAPSHOT----2020-02-22T13:02:07.132202-05:00 Pharo 8.0 - 32bit (stable).3.image priorSource: 157651!!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:03' prior: 33709994!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										ad1  do: [ :a | (a > (ad2   at: (ad1   indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (ad2  at: (ad2   indexOf: a)))  ifTrue: [ ^scndhnd  ].].].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:07' prior: 33712370!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										ad1  do: [ :a | (a > (ad2   at: (ad1   indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (ad2  at: (ad2   indexOf: a)))  ifTrue: [ ^scndhnd  ].].].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:09' prior: 33700898!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection reverse  asArray.smpl2  := (self switch: scndhnd ) asSortedCollection reverse asArray .Transcript show: (frsthnd   ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:09' prior: 33714380!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										Transcript show: 'hi'; cr.										ad1  do: [ :a | (a > (ad2   at: (ad1   indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (ad2  at: (ad2   indexOf: a)))  ifTrue: [ ^scndhnd  ].].].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:17' prior: 33716391!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := (self switch: frsthnd ) asSortedCollection reverse  asArray.smpl2  := (self switch: scndhnd ) asSortedCollection reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:18' prior: 33719059!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse  asArray.smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:20' prior: 33719676!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:22' prior: 33700198!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).Transcript show: q; cr.ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:22' prior: 33720902!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .Transcript show: q; cr.^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:24' prior: 33721625!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ ^false ]. t := t - 1.  ] .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:25' prior: 33722348!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .Transcript show: 'hii'; cr.^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:26' prior: 33720297!deal:  cards|  win |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:26' prior: 33723039!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .Transcript show: 'hii'; cr.^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:26' prior: 33724388!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ Transcript show: 'hii'; cr. ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:27' prior: 33725113!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ Transcript show: 'hii'; cr. ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:27' prior: 33725833!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ Transcript show: 'hii'; cr. ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:28' prior: 33661640!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index). 	                                ( a between: 1 and: 13 ) ifTrue: [temp at: index put: ( a )  ] .                                  ( a between: 14 and: 26 ) ifTrue: [temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].			^temp asSortedCollection reverse asArray.! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:28' prior: 33726553!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:28' prior: 33727988!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .Transcript show: ordd ; cr.((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:29' prior: 33728714!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:33' prior: 33717011!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										Transcript show: ad1; cr.										].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:36' prior: 33730136!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										^scndhnd .										].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:40' prior: 33732004!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:48' prior: 33733857!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := smpl1  select: [:a | a ~= frst].									  tm2 := smpl2  select: [:a | a ~= scd  ].									        ].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:49' prior: 33735704!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) reverse .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) reverse .									                    ].			! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:52' prior: 33737978!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) reverse .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) reverse .									  tm1  do: [ :a | (a > (tm2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:57' prior: 33740286!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) reverse .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) reverse .									  Transcript show: tm2; cr.									  Transcript show: tm1; cr.									  tm1  do: [ :a | (a > (tm2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:57' prior: 33742797!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst])  .									  tm2 := (smpl2  select: [:a | a ~= scd  ])  .									  Transcript show: tm2; cr.									  Transcript show: tm1; cr.									  tm1  do: [ :a | (a > (tm2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 13:58' prior: 33745382!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  Transcript show: tm2; cr.									  Transcript show: tm1; cr.									  tm1  do: [ :a | (a > (tm2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:00' prior: 33747953!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  Transcript show: tm2; cr.									  Transcript show: tm1; cr.									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:02' prior: 33750578!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  Transcript show: tm2; cr.									  Transcript show: tm1; cr.									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:11' prior: 33753199!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2 tm3 tm4| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & a~=frst )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & a~=frst )  ifTrue: [ ^scndhnd  ].].		].! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:12'!ruleRBBooleanPrecedenceRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:12' prior: 33759293!ruleRBBooleanPrecedenceRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #tiebrk: #false)) #'2020-02-22T14:12:06.813202-05:00') )! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:12' prior: 33755821!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & a~=frst )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & a~=frst )  ifTrue: [ ^scndhnd  ].].		].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:13' prior: 33759655!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].		].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:13' prior: 33763115!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:13' prior: 33766579!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:14' prior: 33770078!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].(numa = 8)ifTrue:[    | frst scd| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].				].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:16' prior: 33773585!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].(numa = 8)ifTrue:[    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .	                     tm1   do: [ :a | (a > (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. 			].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:17' prior: 33777376!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].(numa = 8)ifTrue:[    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].  	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .	                     tm1   do: [ :a | (a > (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. 	].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:17' prior: 33781600!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].(numa = 8)ifTrue:[    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].  	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .	                     tm1   do: [ :a | (a > (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value.  ].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:18' prior: 33785822!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [   smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].(numa = 9)ifTrue:[    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].  	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .	                     tm1   do: [ :a | (a > (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value.  ].(numa = 10)ifTrue:[ smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].! !----SNAPSHOT----2020-02-22T14:19:46.108202-05:00 ass.image priorSource: 157757!----SNAPSHOT----2020-02-22T14:20:03.916202-05:00 ass.1.image priorSource: 240017!!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:30' prior: 33723766!deal:  cards|  win ma |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [Transcript show: 'winner'; cr.].(win = scndhnd  ) ifTrue: [Transcript show: 'winner'; cr.]."ma := Array new: 5.ma do: [ :a |   ]."^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:35' prior: 33794688!deal:  cards|  win ma |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [Transcript show: 'winner'; cr.].(win = scndhnd  ) ifTrue: [Transcript show: 'winner2'; cr.]."ma := Array new: 5.ma do: [ :a |   ]."^(self switch: win) asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:35' prior: 33795473!deal:  cards|  win ma |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [Transcript show: 'winner'; cr.].(win = scndhnd  ) ifTrue: [Transcript show: 'winner2'; cr.]."ma := Array new: 5.ma do: [ :a |   ]."^win asArray .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:36' prior: 33796274!deal:  cards|  win ma |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [Transcript show: 'winner'; cr.].(win = scndhnd  ) ifTrue: [Transcript show: 'winner2'; cr.]."ma := Array new: 5.ma do: [ :a |   ]."^(self switch: win) frsthnd .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:36' prior: 33797060!deal:  cards|  win ma |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [Transcript show: 'winner'; cr.].(win = scndhnd  ) ifTrue: [Transcript show: 'winner2'; cr.]."ma := Array new: 5.ma do: [ :a |   ]."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:37' prior: 33797861!deal:  cards|  win ma |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [Transcript show: 'winner1'; cr.] ifFalse: [Transcript show: 'lose1'; cr. ].(win = scndhnd  ) ifTrue: [Transcript show: 'winner2'; cr.]ifFalse: [Transcript show: 'lose2'; cr. ]."ma := Array new: 5.ma do: [ :a |   ]."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:38' prior: 33798655!deal:  cards|  win ma |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.ma do: [ :a |   ].^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:46' prior: 33799533!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.win do: [ :a |  ma at: (win indexOf: a) put: [ ( (smpl1 at: (win indexOf: a) )asString ) , (ad1 at: a)asString  ]  ].^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:47' prior: 33800236!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.win do: [ :a |  ma at: (win indexOf: a) put: [ ( (smpl1 at: (win indexOf: a) )asString ) , (ad1 at: a)asString  ]  ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:47' prior: 33801041!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.win do: [ :a |  ma at: (win indexOf: a) put: [ ( (smpl1 at: (win indexOf: a) )) , (ad1 at: a) ]  ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:49' prior: 33801876!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.win do: [ :a |  ma at: (win indexOf: a) put: [ ( (smpl1 at: (win indexOf: a) ))   ]  ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:50' prior: 33802693!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) ))    ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:50' prior: 33803498!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) , (ad1 at: a)   ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:51' prior: 33804300!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (ad1 at: a) asString  ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:54' prior: 33805115!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (ad1 at: a) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (ad2 at: a) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !----SNAPSHOT----2020-02-22T14:55:44.531202-05:00 ass.1.image priorSource: 240098!!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56'!ruleRBGlobalVariablesUsageV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56' prior: 33807031!ruleRBGlobalVariablesUsageV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #deal: #false)) #'2020-02-22T14:56:04.026202-05:00') )! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56' prior: 33691183!ruleRBModifiesCollectionRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #tiebrk: #false)) #'2020-02-22T12:23:23.889202-05:00') #(#(#RGMethodDefinition #(#Poker #deal: #false)) #'2020-02-22T14:56:09.737202-05:00') )! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56' prior: 33685594!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #tiebrk: #false)) #'2020-02-22T11:14:40.031202-05:00') #(#(#RGMethodDefinition #(#Poker #deal: #false)) #'2020-02-22T14:56:13.023202-05:00') )! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56'!ruleGRTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56' prior: 33808030!ruleGRTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #deal: #false)) #'2020-02-22T14:56:16.647202-05:00') )! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56'!ruleRBImplementedNotSentRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56' prior: 33808420!ruleRBImplementedNotSentRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #deal: #false)) #'2020-02-22T14:56:20.641202-05:00') )! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56'!ruleRBStringConcatenationRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 14:56' prior: 33808786!ruleRBStringConcatenationRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #deal: #false)) #'2020-02-22T14:56:28.550202-05:00') )! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:58' prior: 33805948!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 'S'->4; yourself.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (ad1 at: a) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (ad2 at: a) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:59' prior: 33809150!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 'S'->4.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (ad1 at: a) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (ad2 at: a) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:59' prior: 33810271!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 'S'->4.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a)) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 14:59' prior: 33811382!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( smpl2  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 'S'->4.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a)) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:00' prior: 33812509!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( ad1 ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 'S'->4.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a)) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:00' prior: 33813636!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( ad2 ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 'S'->4.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a)) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:00' prior: 33814760!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (smpl1    ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 'S'->4.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a)) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:02' prior: 33815884!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 'S'->4.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a)) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:06' prior: 33817013!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a)) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:08' prior: 33818144!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:11' prior: 33819275!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 valueAt:  a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:12' prior: 33820407!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 valueAt:  a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i valueAt: (ad2 valueAt: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:13' prior: 33821545!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:14' prior: 33822693!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.Transcript show: (ad2   ) ; cr.Transcript show: (i   ) ; cr.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:14' prior: 33823825!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.Transcript show: (win  ) ; cr.Transcript show: (ad2   ) ; cr.Transcript show: (i   ) ; cr.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:16' prior: 33825018!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (ad2   ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:16' prior: 33826242!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: ( smpl2     ) ; cr.Transcript show: ( scndhnd  ) ; cr.Transcript show: (ad2   ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].Transcript show: (win  ) ; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:17' prior: 33827437!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .Transcript show: (ad2   ) ; cr.win := self chk: frsthnd nd: scndhnd .(win = frsthnd ) ifTrue: [ ].i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.Transcript show: ( smpl2   ) ; cr.Transcript show: (win  ) ; cr.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'as yet unclassified' stamp: 'georg 2/22/2020 15:26'!switcha: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index). 	                                ( a between: 1 and: 13 ) ifTrue: [temp at: index put: ( a )  ] .                                  ( a between: 14 and: 26 ) ifTrue: [temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].			^temp asSortedCollection asArray.! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:27' prior: 33828632!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switch: frsthnd )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:28' prior: 33830470!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switch: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:28' prior: 33831542!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switch: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:28' prior: 33832618!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switch: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:28' prior: 33833693!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:29' prior: 33834769!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:29' prior: 33835846!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: (ma   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:31' prior: 33837026!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:36' prior: 33838207!deal:  cards|  win ma i smpl22 ha |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].ha := #( 4 6 2 1 5 0).ha asSortedCollection reverse asArray.Transcript show: ((ha)  ).Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 15:36'!ruleRBCodeCruftLeftInMethodsRuleV1FalsePositive	^ #()! !!ManifestLAB class methodsFor: 'code-critics' stamp: 'georg 2/22/2020 15:36' prior: 33840727!ruleRBCodeCruftLeftInMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Poker #deal: #false)) #'2020-02-22T15:36:59.729202-05:00') )! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:37' prior: 33839419!deal:  cards|  win ma i smpl22 ha |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].ha := #( 4 6 2 1 5 0).ha asSortedCollection reverse asArray.Transcript show: ((ha)  ).Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:37' prior: 33841097!deal:  cards|  win ma i smpl22 ha |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].ha := #( 4 6 2 1 5 0).ha asSortedCollection reverse asArray.Transcript show: ((ha)  )."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:38' prior: 33842403!deal:  cards|  win ma i smpl22 ha |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].ha := #( 4 6 2 1 5 0).ha asSortedCollection reverse asArray.Transcript show: ((ha) asSortedCollection reverse asArray )."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:38' prior: 33843712!deal:  cards|  win ma i smpl22 ha |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].ha := #( 4 6 2 1 5 0).ha asSortedCollection reverse asArray.Transcript show: (((ha) asSortedCollection reverse asArray) asSortedCollection  )."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:38' prior: 33845055!deal:  cards|  win ma i smpl22 ha |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].ha := #( 4 6 2 1 5 0).ha asSortedCollection reverse asArray.Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:39' prior: 33846420!deal:  cards|  win ma i smpl22 ha |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:39' prior: 33847700!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."Transcript show: (smpl22   ) ; cr.Transcript show: (win  ) ; cr.Transcript show: (scndhnd    ) ; cr."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:39' prior: 33848919!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection) reverse asArray  .smpl2  := ((self switch: scndhnd ) asSortedCollection) reverse asArray .smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:40' prior: 33850135!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd )).smpl2  := ((self switch: scndhnd ) ).smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:42' prior: 33851245!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd )).smpl2  := ((self switch: scndhnd ) ).smpl22  := ((self switcha: scndhnd  )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].""Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:44' prior: 33650451!fullHuse: cards| temp |temp := (self switch: cards) asSortedCollection .Transcript show: temp; cr.( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 )) 														& ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].														( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4)) 														& ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].														^false.														! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:47' prior: 33729439!isStrght: hand | ordd  q  t|q := true .ordd := self switch: hand asSortedCollection reverse asArray.((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:47' prior: 33853829!isStrght: hand | ordd  q  t|q := true .ordd := (self switch: hand )asSortedCollection reverse asArray.((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 5) &	                            ((ordd at: 2) = 4) &	                            ((ordd at: 3) = 3) &	                            ((ordd at: 4) = 2)  )  ifTrue: [ ^true ] ] .((ordd at: 5) = 1 )  ifTrue: [ (((ordd at: 1) = 13) &	                            ((ordd at: 2) = 12) &	                            ((ordd at: 3) = 11) & 	                            ((ordd at: 4) = 10)) ifTrue: [ ^true ] ] .t := (ordd at: 1).ordd do: [ :a | ( a = t ) ifFalse:[ q := false ]. t := t - 1.  ] .^q .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:48' prior: 33727301!switch: hand| index temp a|temp := Array new: 5.index := 1.[ index <= hand size ] whileTrue: [  a := ( hand at: index). 	                                ( a between: 1 and: 13 ) ifTrue: [temp at: index put: ( a )  ] .                                  ( a between: 14 and: 26 ) ifTrue: [temp at: index put: ( a - 13 )  ] .								               ( a between: 27 and: 39 ) ifTrue: [ temp at: index put: ( a - 26 ) ] .								               ( a between: 40 and: 52 ) ifTrue: [ temp at: index put: ( a - 39 ) ] .								                index := index + 1 ].			^temp.! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:48' prior: 33660503!rylflush: hand| temp |temp := self switch: hand asSortedCollection reverse asArray .( (self isFlush: hand ) & (self isStrght: hand) ) & ( (temp at: 5) = 1 ) & ( (temp at: 1) = 13 )ifTrue: [ ^true ]. ^false.! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:48' prior: 33855945!rylflush: hand| temp |temp := (self switch: hand) asSortedCollection reverse asArray .( (self isFlush: hand ) & (self isStrght: hand) ) & ( (temp at: 5) = 1 ) & ( (temp at: 1) = 13 )ifTrue: [ ^true ]. ^false.! !Poker removeSelector: #switcha:!!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:50' prior: 33852283!deal:  cards|  win ma i smpl22 |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd )).smpl2  := ((self switch: scndhnd )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].""Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:50' prior: 33856567!deal:  cards|  win ma i  |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd )).smpl2  := ((self switch: scndhnd )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'."ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl22 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].""Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:51' prior: 33857568!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd )).smpl2  := ((self switch: scndhnd )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ]."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:51' prior: 33858563!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ]."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:51' prior: 33859554!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) ).smpl2  := ((self switch: scndhnd )).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ]."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:52' prior: 33860615!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ]."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:53' prior: 33861607!deal:  cards|  win ma i smpl3 smpl4|frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).smpl3 :=((self switch: frsthnd ) ).smpl4 := ((self switch: scndhnd ) ).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ]."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:53' prior: 33862669!deal:  cards|  win ma i smpl3 smpl4|frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).smpl3 :=((self switch: frsthnd ) ).smpl4 := ((self switch: scndhnd ) ).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl3 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl4 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ]."Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 15:54' prior: 33863814!deal:  cards|  win ma i smpl3 smpl4|frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).smpl3 :=((self switch: frsthnd ) ).smpl4 := ((self switch: scndhnd ) ).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl3 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl4 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:02' prior: 33864959!deal:  cards|  win ma i smpl3 smpl4|frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).smpl3 :=((self switch: frsthnd ) ).smpl4 := ((self switch: scndhnd ) ).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:05' prior: 33853325!fullHuse: cards| temp |temp := (self switch: cards) asSortedCollection .( ((temp at: 1) = (temp at: 2 )) & ((temp at: 2) = (temp at: 3 )) 														& ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].														( ((temp at: 1) = (temp at: 2 )) & ((temp at: 3) = (temp at: 4)) 														& ((temp at: 4) = (temp at: 5 ))) ifTrue: [ ^true ].														^false.														! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:07' prior: 33866101!deal:  cards|  win ma i smpl3 smpl4|frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:07' prior: 33867720!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:08' prior: 33868790!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).win := self chk: frsthnd nd: scndhnd .i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.Transcript show: win; cr.Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr.^(self switch: win)  .! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:09' prior: 33869849!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray   ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:10' prior: 33870991!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray reverse    ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:18' prior: 33872135!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd )  ).smpl2  := ((self switch: scndhnd ) ).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray reverse    ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:18' prior: 33873288!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) asSortedCollection reverse asArray ).smpl2  := ((self switch: scndhnd ) asSortedCollection reverse asArray).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray reverse    ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:19' prior: 33874373!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) ).smpl2  := ((self switch: scndhnd ) ).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray reverse    ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:20' prior: 33875526!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) ).smpl2  := ((self switch: scndhnd ) ).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray     ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:21' prior: 33876610!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) ).smpl2  := ((self switch: scndhnd ) ).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray reverse      ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:21' prior: 33877687!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) ).smpl2  := ((self switch: scndhnd ) ).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray       ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:21' prior: 33878773!deal:  cards|  win ma i |frsthnd := cards selectEveryFirst asSortedCollection reverse asArray.scndhnd := cards selectEverySecond asSortedCollection reverse asArray.ad1 := Dictionary new. ad2 := Dictionary new. ad1 := self suitsa: frsthnd .ad2 := self suitsa: scndhnd .smpl1  := ((self switch: frsthnd ) ).smpl2  := ((self switch: scndhnd ) ).Transcript show: smpl1 ; cr.Transcript show: smpl2; cr.win := self chk: frsthnd nd: scndhnd .Transcript show: win; cr.i := Dictionary new.                                       i add: 1->'C'; add: 2->'D'; add: 3->'H'; add: 4->'S'.ma := Array new: 5.(win = frsthnd ) ifTrue: [  win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl1 at: (win indexOf: a) )) asString  , (i at: (ad1 at: a )) asString  ].] ifFalse: [ win do: [ :a |  ma at: (win indexOf: a) put:  ( (smpl2 at: (win indexOf: a) )) asString  , (i at: (ad2 at: a)) asString  ]. ].Transcript show: ((ma ) asOrderedCollection asArray  reverse       ) ; cr."^(self switch: win)  ."! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:30' prior: 33790043!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [    ((smpl1 includes: 1) & ((smpl2 includes: 1) not) ) ifTrue:[ ^frsthnd  ]  .	                            smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].(numa = 9)ifTrue:[    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].  	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .	                     tm1   do: [ :a | (a > (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value.  ].(numa = 10)ifTrue:[ smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:30' prior: 33880940!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [    ((smpl1 includes: 1) & ((smpl2 includes: 1) not) ) ifTrue:[ ^frsthnd  ]  .										((smpl2 includes: 1) & ((smpl1 includes: 1) not) ) ifTrue:[ ^frsthnd  ]  .	                            smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].(numa = 9)ifTrue:[    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].  	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .	                     tm1   do: [ :a | (a > (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value.  ].(numa = 10)ifTrue:[ smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 16:30' prior: 33885526!tiebrk: numa| suitbrk  occ|suitbrk := [ (((ad1 values) at: 1  ) >  (ad2 values) at: 1 ) ifTrue: [ ^frsthnd  ]	                                                           ifFalse:[ ^scndhnd  ] ].( numa = 1 ) ifTrue: [ suitbrk value ] .(numa = 2 ) ifTrue: [  (smpl1 at: 2) > (smpl2 at: 2) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 2) < (smpl2 at: 2) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									occ := [ :arrr :n | arrr  detect: [ :a  | ((arrr occurrencesOf: a) = n )]].	(numa = 3) ifTrue: [   | frst scd | .	                     frst := (occ  value: smpl1   value: 4) .	                     scd := (occ  value: smpl2   value: 4) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                      suitbrk value.  ].(numa = 4) ifTrue:  [   | frst scd |.	                      frst := (occ  value: smpl1   value: 3) .	                      scd := (occ  value: smpl2   value: 3) .	 									(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .										(frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].										suitbrk value.  ].(numa = 5) ifTrue: [    ((smpl1 includes: 1) & ((smpl2 includes: 1) not) ) ifTrue:[ ^frsthnd  ]  .										((smpl2 includes: 1) & ((smpl1 includes: 1) not) ) ifTrue:[ ^scndhnd   ]  .	                            smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].(numa = 6) ifTrue: [    (smpl1 at: 1) > (smpl2 at: 1) ifTrue:  [ ^frsthnd  ].										(smpl1 at: 1) < (smpl2 at: 1) ifTrue:  [ ^scndhnd  ].										suitbrk value. ].									(numa = 7) ifTrue: [   | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 3) .	                     scd := (occ  value: smpl2   value: 3) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  tm1  do: [ :a | (a > (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                      (a < (tm2  at: (tm2  indexOf: a)))  ifTrue: [ ^scndhnd  ].] .                                  suitbrk value.].(numa = 8)ifTrue: [    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd]. 	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .									  frst := (occ  value: tm1   value: 2) .	                     scd := (occ  value: tm2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1  do: [ :a | ((a > (tm2 at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^frsthnd  ].	                                        ((a < (tm2  at: (tm1  indexOf: a))) & (a~=frst) )  ifTrue: [ ^scndhnd  ].].                       suitbrk value. ].(numa = 9)ifTrue:[    | frst scd tm1 tm2| .	                     frst := (occ  value: smpl1   value: 2) .	                     scd := (occ  value: smpl2   value: 2) .	                     (frst > scd) ifTrue: [ ^frsthnd].  	                     (frst < scd) ifTrue: [ ^scndhnd].	                     tm1 := (smpl1  select: [:a | a ~= frst]) asSortedCollection reverse   .									  tm2 := (smpl2  select: [:a | a ~= scd  ]) asSortedCollection reverse .	                     tm1   do: [ :a | (a > (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (tm2  at: (tm1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value.  ].(numa = 10)ifTrue:[ smpl1   do: [ :a | (a > (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^frsthnd  ].	                                        (a < (smpl2  at: (smpl1  indexOf: a)))  ifTrue: [ ^scndhnd  ].].                                   suitbrk value. ].! !----SNAPSHOT----2020-02-22T16:31:41.970202-05:00 ass.2.image priorSource: 252437!----QUIT----2020-02-22T16:31:57.404202-05:00 ass.2.image priorSource: 340362!----QUIT/NOSAVE----2020-02-22T16:56:52.782657-05:00 ass.2.image priorSource: 340445!!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 20:52' prior: 33890197!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 4.			tmp4 := tmp2 value: smpl2 value: 4.			(tmp3 = 1 ) & (tmp4 = 1) not				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & (tmp3 = 1) not				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg6 | arg6 ~= tmp3 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg7 | arg7 ~= tmp4 ]) asSortedCollection				reverse.			tmp5				do: [ :arg8 | 					arg8 > (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp8 tmp9 |			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg9 | arg9 ~= tmp8 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg10 | arg10 ~= tmp9 ])				asSortedCollection reverse.			tmp8 := tmp2 value: tmp5 value: 2.			tmp9 := tmp2 value: tmp6 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5				do: [ :arg11 | 					arg11 > (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg12 | arg12 ~= tmp3 ])				asSortedCollection reverse.			tmp6 := (smpl2 select: [ :arg13 | arg13 ~= tmp4 ])				asSortedCollection reverse.			tmp5				do: [ :arg14 | 					arg14 > (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 20:52' prior: 33895117!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp5 tmp6 tmp7 tmp8 tmp9 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp8 := tmp2 value: smpl1 value: 4.			tmp9 := tmp2 value: smpl2 value: 4.			tmp8 = 1 & (tmp9 = 1) not				ifTrue: [ ^ frsthnd ].			tmp9 = 1 & (tmp8 ~= 1)				ifTrue: [ ^ scndhnd ].			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp8 := tmp2 value: smpl1 value: 3.			tmp9 := tmp2 value: smpl2 value: 3.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp8 := tmp2 value: smpl1 value: 3.			tmp9 := tmp2 value: smpl2 value: 3.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp6 := (smpl1 select: [ :arg6 | arg6 ~= tmp8 ]) asSortedCollection				reverse.			tmp7 := (smpl2 select: [ :arg7 | arg7 ~= tmp9 ]) asSortedCollection				reverse.			tmp6				do: [ :arg8 | 					arg8 > (tmp7 at: (tmp7 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp7 at: (tmp7 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp10 tmp11 |			tmp10 := tmp2 value: smpl1 value: 2.			tmp11 := tmp2 value: smpl2 value: 2.			tmp10 > tmp11				ifTrue: [ ^ frsthnd ].			tmp10 < tmp11				ifTrue: [ ^ scndhnd ].			tmp6 := (smpl1 select: [ :arg9 | arg9 ~= tmp10 ])				asSortedCollection reverse.			tmp7 := (smpl2 select: [ :arg10 | arg10 ~= tmp11 ])				asSortedCollection reverse.			tmp10 := tmp2 value: tmp6 value: 2.			tmp11 := tmp2 value: tmp7 value: 2.			tmp10 > tmp11				ifTrue: [ ^ frsthnd ].			tmp10 < tmp11				ifTrue: [ ^ scndhnd ].			tmp6				do: [ :arg11 | 					arg11 > (tmp7 at: (tmp6 indexOf: arg11)) & (arg11 ~= tmp10)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp7 at: (tmp6 indexOf: arg11)) & (arg11 ~= tmp10)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp6 := (smpl1 select: [ :arg12 | arg12 ~= tmp8 ])				asSortedCollection reverse.			tmp7 := (smpl2 select: [ :arg13 | arg13 ~= tmp9 ])				asSortedCollection reverse.			tmp6				do: [ :arg14 | 					arg14 > (tmp7 at: (tmp6 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp7 at: (tmp6 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 20:52' prior: 33898888!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 4.			tmp4 := tmp2 value: smpl2 value: 4.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg6 | arg6 ~= tmp3 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg7 | arg7 ~= tmp4 ]) asSortedCollection				reverse.			tmp5				do: [ :arg8 | 					arg8 > (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp8 tmp9 |			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg9 | arg9 ~= tmp8 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg10 | arg10 ~= tmp9 ])				asSortedCollection reverse.			tmp8 := tmp2 value: tmp5 value: 2.			tmp9 := tmp2 value: tmp6 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5				do: [ :arg11 | 					arg11 > (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg12 | arg12 ~= tmp3 ])				asSortedCollection reverse.			tmp6 := (smpl2 select: [ :arg13 | arg13 ~= tmp4 ])				asSortedCollection reverse.			tmp5				do: [ :arg14 | 					arg14 > (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 20:53' prior: 33902674!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 4.			tmp4 := tmp2 value: smpl2 value: 4.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg6 | arg6 ~= tmp3 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg7 | arg7 ~= tmp4 ]) asSortedCollection				reverse.			tmp5				do: [ :arg8 | 					arg8 > (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp8 tmp9 |			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg9 | arg9 ~= tmp8 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg10 | arg10 ~= tmp9 ])				asSortedCollection reverse.			tmp8 := tmp2 value: tmp5 value: 2.			tmp9 := tmp2 value: tmp6 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5				do: [ :arg11 | 					arg11 > (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg12 | arg12 ~= tmp3 ])				asSortedCollection reverse.			tmp6 := (smpl2 select: [ :arg13 | arg13 ~= tmp4 ])				asSortedCollection reverse.			tmp5				do: [ :arg14 | 					arg14 > (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 20:55' prior: 33906449!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 4.			tmp4 := tmp2 value: smpl2 value: 4.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg6 | arg6 ~= tmp3 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg7 | arg7 ~= tmp4 ]) asSortedCollection				reverse.			tmp5				do: [ :arg8 | 					arg8 > (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp8 tmp9 |			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg9 | arg9 ~= tmp8 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg10 | arg10 ~= tmp9 ])				asSortedCollection reverse.			tmp8 := tmp2 value: tmp5 value: 2.			tmp9 := tmp2 value: tmp6 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5				do: [ :arg11 | 					arg11 > (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg12 | arg12 ~= tmp3 ])				asSortedCollection reverse.			tmp6 := (smpl2 select: [ :arg13 | arg13 ~= tmp4 ])				asSortedCollection reverse.			tmp5				do: [ :arg14 | 					arg14 > (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 20:57' prior: 33910345!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 4.			tmp4 := tmp2 value: smpl2 value: 4.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			(smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg6 | arg6 ~= tmp3 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg7 | arg7 ~= tmp4 ]) asSortedCollection				reverse.			tmp5				do: [ :arg8 | 					arg8 > (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp8 tmp9 |			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg9 | arg9 ~= tmp8 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg10 | arg10 ~= tmp9 ])				asSortedCollection reverse.			tmp8 := tmp2 value: tmp5 value: 2.			tmp9 := tmp2 value: tmp6 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5				do: [ :arg11 | 					arg11 > (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg12 | arg12 ~= tmp3 ])				asSortedCollection reverse.			tmp6 := (smpl2 select: [ :arg13 | arg13 ~= tmp4 ])				asSortedCollection reverse.			tmp5				do: [ :arg14 | 					arg14 > (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 20:58' prior: 33914362!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 4.			tmp4 := tmp2 value: smpl2 value: 4.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			(smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg6 | arg6 ~= tmp3 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg7 | arg7 ~= tmp4 ]) asSortedCollection				reverse.			tmp5				do: [ :arg8 | 					arg8 > (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp8 tmp9 |			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg9 | arg9 ~= tmp8 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg10 | arg10 ~= tmp9 ])				asSortedCollection reverse.			tmp8 := tmp2 value: tmp5 value: 2.			tmp9 := tmp2 value: tmp6 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5				do: [ :arg11 | 					arg11 > (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg12 | arg12 ~= tmp3 ])				asSortedCollection reverse.			tmp6 := (smpl2 select: [ :arg13 | arg13 ~= tmp4 ])				asSortedCollection reverse.			tmp5				do: [ :arg14 | 					arg14 > (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 21:01' prior: 33918531!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 4.			tmp4 := tmp2 value: smpl2 value: 4.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			(smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 3.			tmp4 := tmp2 value: smpl2 value: 3.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg6 | arg6 ~= tmp3 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg7 | arg7 ~= tmp4 ]) asSortedCollection				reverse.			tmp5				do: [ :arg8 | 					arg8 > (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp6 at: (tmp6 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp8 tmp9 |			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg9 | arg9 ~= tmp8 ]) asSortedCollection				reverse.			tmp6 := (smpl2 select: [ :arg10 | arg10 ~= tmp9 ])				asSortedCollection reverse.			tmp8 := tmp2 value: tmp5 value: 2.			tmp9 := tmp2 value: tmp6 value: 2.			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp5				do: [ :arg11 | 					arg11 > (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp6 at: (tmp5 indexOf: arg11)) & (arg11 ~= tmp8)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp3 := tmp2 value: smpl1 value: 2.			tmp4 := tmp2 value: smpl2 value: 2.			(tmp3 = 1 ) & ((tmp4 = 1) not)				ifTrue: [ ^ frsthnd ].			(tmp4 = 1) & ((tmp3 = 1) not)				ifTrue: [ ^ scndhnd ].			tmp3 > tmp4				ifTrue: [ ^ frsthnd ].			tmp3 < tmp4				ifTrue: [ ^ scndhnd ].			tmp5 := (smpl1 select: [ :arg12 | arg12 ~= tmp3 ])				asSortedCollection reverse.			tmp6 := (smpl2 select: [ :arg13 | arg13 ~= tmp4 ])				asSortedCollection reverse.			tmp5				do: [ :arg14 | 					arg14 > (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp6 at: (tmp5 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 21:04' prior: 33922821!tiebrk: arg1	| tmp1 tmp2 tmp3 tmp5 tmp6 tmp7 tmp8 tmp9 |	tmp1 := [ ((ad1 values at: 1) > ad2 values at: 1)		ifTrue: [ ^ frsthnd ].	^ scndhnd ].	arg1 = 1		ifTrue: [ tmp1 value ].	arg1 = 2		ifTrue: [ (smpl1 at: 2) > (smpl2 at: 2)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 2) < (smpl2 at: 2)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	tmp2 := [ :arg2 :arg3 | arg2 detect: [ :arg4 | (arg2 occurrencesOf: arg4) = arg3 ] ].	arg1 = 3		ifTrue: [ tmp8 := tmp2 value: smpl1 value: 4.			tmp9 := tmp2 value: smpl2 value: 4.			tmp8 = 1 & (tmp9 = 1) not				ifTrue: [ ^ frsthnd ].			tmp9 = 1 & (tmp8 = 1) not				ifTrue: [ ^ scndhnd ].			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 4		ifTrue: [ tmp8 := tmp2 value: smpl1 value: 3.			tmp9 := tmp2 value: smpl2 value: 3.			tmp8 = 1 & (tmp9 = 1) not				ifTrue: [ ^ frsthnd ].			tmp9 = 1 & (tmp8 = 1) not				ifTrue: [ ^ scndhnd ].			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 = 1 & (tmp9 = 1) not				ifTrue: [ ^ frsthnd ].			tmp9 = 1 & (tmp8 = 1) not				ifTrue: [ ^ scndhnd ].			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 5		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg5 | 					arg5 > (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ frsthnd ].					arg5 < (smpl2 at: (smpl1 indexOf: arg5))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 6		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			(smpl1 at: 1) > (smpl2 at: 1)				ifTrue: [ ^ frsthnd ].			(smpl1 at: 1) < (smpl2 at: 1)				ifTrue: [ ^ scndhnd ].			tmp1 value ].	arg1 = 7		ifTrue: [ tmp8 := tmp2 value: smpl1 value: 3.			tmp9 := tmp2 value: smpl2 value: 3.			tmp8 = 1 & (tmp9 = 1) not				ifTrue: [ ^ frsthnd ].			tmp9 = 1 & (tmp8 = 1) not				ifTrue: [ ^ scndhnd ].			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp6 := (smpl1 select: [ :arg6 | arg6 ~= tmp8 ]) asSortedCollection				reverse.			tmp7 := (smpl2 select: [ :arg7 | arg7 ~= tmp9 ]) asSortedCollection				reverse.			tmp6				do: [ :arg8 | 					arg8 > (tmp7 at: (tmp7 indexOf: arg8))						ifTrue: [ ^ frsthnd ].					arg8 < (tmp7 at: (tmp7 indexOf: arg8))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 8		ifTrue: [ | tmp10 tmp11 |			tmp10 := tmp2 value: smpl1 value: 2.			tmp11 := tmp2 value: smpl2 value: 2.			tmp10 > tmp11				ifTrue: [ ^ frsthnd ].			tmp10 < tmp11				ifTrue: [ ^ scndhnd ].			tmp6 := (smpl1 select: [ :arg9 | arg9 ~= tmp10 ])				asSortedCollection reverse.			tmp7 := (smpl2 select: [ :arg10 | arg10 ~= tmp11 ])				asSortedCollection reverse.			tmp10 := tmp2 value: tmp6 value: 2.			tmp11 := tmp2 value: tmp7 value: 2.			tmp10 > tmp11				ifTrue: [ ^ frsthnd ].			tmp10 < tmp11				ifTrue: [ ^ scndhnd ].			tmp6				do: [ :arg11 | 					arg11 > (tmp7 at: (tmp6 indexOf: arg11)) & (arg11 ~= tmp10)						ifTrue: [ ^ frsthnd ].					arg11 < (tmp7 at: (tmp6 indexOf: arg11)) & (arg11 ~= tmp10)						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 9		ifTrue: [ tmp8 := tmp2 value: smpl1 value: 2.			tmp9 := tmp2 value: smpl2 value: 2.			tmp8 = 1 & (tmp9 = 1) not				ifTrue: [ ^ frsthnd ].			tmp9 = 1 & (tmp8 = 1) not				ifTrue: [ ^ scndhnd ].			tmp8 > tmp9				ifTrue: [ ^ frsthnd ].			tmp8 < tmp9				ifTrue: [ ^ scndhnd ].			tmp6 := (smpl1 select: [ :arg12 | arg12 ~= tmp8 ])				asSortedCollection reverse.			tmp7 := (smpl2 select: [ :arg13 | arg13 ~= tmp9 ])				asSortedCollection reverse.			tmp6				do: [ :arg14 | 					arg14 > (tmp7 at: (tmp6 indexOf: arg14))						ifTrue: [ ^ frsthnd ].					arg14 < (tmp7 at: (tmp6 indexOf: arg14))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ].	arg1 = 10		ifTrue: [ (smpl1 includes: 1) & (smpl2 includes: 1) not				ifTrue: [ ^ frsthnd ].			(smpl2 includes: 1) & (smpl1 includes: 1) not				ifTrue: [ ^ scndhnd ].			smpl1				do: [ :arg15 | 					arg15 > (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ frsthnd ].					arg15 < (smpl2 at: (smpl1 indexOf: arg15))						ifTrue: [ ^ scndhnd ] ].			tmp1 value ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 21:05' prior: 33666492!chk: arg1 nd: arg2	| tmp1 tmp2 tmp3 tmp5 tmp7 |	tmp1 := self whatme: arg1.	tmp2 := self whatme: arg2.	tmp1 < tmp2		ifTrue: [ ^ arg1 ].	tmp1 > tmp2		ifTrue: [ ^ arg2 ].	tmp1 = tmp2		ifTrue: [ ^ self tiebrk: tmp1 ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 21:05' prior: 33931773!chk: arg1 nd: arg2	| tmp1 tmp2 |	tmp1 := self whatme: arg1.	tmp2 := self whatme: arg2.	tmp1 < tmp2		ifTrue: [ ^ arg1 ].	tmp1 > tmp2		ifTrue: [ ^ arg2 ].	tmp1 = tmp2		ifTrue: [ ^ self tiebrk: tmp1 ]! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 21:06' prior: 33879852!deal: arg1	| tmp1 tmp2 tmp3 tmp5 tmp7 tmp9 tmp11 |	frsthnd := arg1 selectEveryFirst asSortedCollection reverse asArray.	scndhnd := arg1 selectEverySecond asSortedCollection reverse asArray.	ad1 := Dictionary new.	ad2 := Dictionary new.	ad1 := self suitsa: frsthnd.	ad2 := self suitsa: scndhnd.	smpl1 := self switch: frsthnd.	smpl2 := self switch: scndhnd.		tmp1 := self chk: frsthnd nd: scndhnd.		tmp3 := Dictionary new.	tmp3		add: 1 -> 'C';		add: 2 -> 'D';		add: 3 -> 'H';		add: 4 -> 'S'.	tmp2 := Array new: 5.	tmp1 = frsthnd		ifTrue: [ tmp1				do: [ :arg2 | 					tmp2						at: (tmp1 indexOf: arg2)						put:							(smpl1 at: (tmp1 indexOf: arg2)) asString								, (tmp3 at: (ad1 at: arg2)) asString ] ]		ifFalse: [ tmp1				do: [ :arg3 | 					tmp2						at: (tmp1 indexOf: arg3)						put:							(smpl2 at: (tmp1 indexOf: arg3)) asString								, (tmp3 at: (ad2 at: arg3)) asString ] ].	tmp11 := Transcript.	tmp11		show: tmp2 asOrderedCollection asArray reverse;		cr! !!Poker methodsFor: 'main' stamp: 'georg 2/22/2020 21:06' prior: 33932356!deal: arg1	| tmp1 tmp2 tmp3 tmp5 tmp7 tmp9 tmp11 |	frsthnd := arg1 selectEveryFirst asSortedCollection reverse asArray.	scndhnd := arg1 selectEverySecond asSortedCollection reverse asArray.	ad1 := Dictionary new.	ad2 := Dictionary new.	ad1 := self suitsa: frsthnd.	ad2 := self suitsa: scndhnd.	smpl1 := self switch: frsthnd.	smpl2 := self switch: scndhnd.		tmp1 := self chk: frsthnd nd: scndhnd.		tmp3 := Dictionary new.	tmp3		add: 1 -> 'C';		add: 2 -> 'D';		add: 3 -> 'H';		add: 4 -> 'S'.	tmp2 := Array new: 5.	tmp1 = frsthnd		ifTrue: [ tmp1				do: [ :arg2 | 					tmp2						at: (tmp1 indexOf: arg2)						put:							(smpl1 at: (tmp1 indexOf: arg2)) asString								, (tmp3 at: (ad1 at: arg2)) asString ] ]		ifFalse: [ tmp1				do: [ :arg3 | 					tmp2						at: (tmp1 indexOf: arg3)						put:							(smpl2 at: (tmp1 indexOf: arg3)) asString								, (tmp3 at: (ad2 at: arg3)) asString ] ].	^ tmp2 asOrderedCollection asArray reverse.	! !----SNAPSHOT----2020-02-22T21:07:49.840974-05:00 ass.3.image priorSource: 340445!----SNAPSHOT----2020-02-22T21:08:09.225974-05:00 ass.3.image priorSource: 379976!----QUIT----2020-02-22T21:08:39.070974-05:00 ass.3.image priorSource: 380059!